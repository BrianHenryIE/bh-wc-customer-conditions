<?php
/**
 * Returns a WC_Customer subclass â€“ one of:
 * - the logged in user
 * - the user matching the billing address
 * - a temporary user whose past orders when placed without an account (maybe zero) are searched and compiled.
 *
 * TODO: Need to refresh checkout when billing address is added. i.e. the javascript that reloads when different
 * postage methods/ country is changed, should fire when the email is entered so everything is refreshed and
 * this is invoked.
 */

namespace BrianHenryIE\WC_Customer_Conditions\WooCommerce_Conditional_Shipping_And_Payments;

use WC_Customer;
use WC_Order;

/**
 *
 */
class WC_CSP_Condition_Customer extends WC_Customer {

	/**
	 * This is used for counting past orders of customers with past orders but without accounts.
	 *
	 * @see WC_CSP_Condition_Customer::get_order_count()
	 *
	 * @var ?int The number of past order the accountless customer has.
	 */
	protected $calculated_order_count;

	/**
	 *
	 * @see WC_CSP_Condition_Customer::get_total_spent()
	 *
	 * @var ?int
	 */
	protected $calculated_total_spent;

	/**
	 * WC_CSP_Condition_Customer constructor.
	 *
	 * @param WC_Customer|int $_data
	 * @param bool            $is_session
	 * @throws \Exception
	 */
	public function __construct( $_data = 0, $is_session = false ) {

		$user_id = get_current_user_id();

		if ( 0 === $user_id ) {

			$billing_email = $this->find_billing_email();

			$user_id = intval( email_exists( $billing_email ?? '' ) );

		}

		// TODO: Maybe $is_session should be true here.

		parent::__construct( $user_id, $is_session );

		if ( 0 === $user_id && ! empty( $billing_email ) ) {

			// No user account for this email address

			$this->generate_fake_customer( $billing_email );

		}
	}


	/**
	 *
	 * @see WC_Customer::get_total_spent()
	 *
	 * @return float|int
	 */
	public function get_total_spent() {
		return $this->calculated_total_spent ?? parent::get_total_spent();
	}

	/**
	 * @see WC_Customer::get_order_count()
	 *
	 * @return int
	 */
	public function get_order_count() {

		return $this->calculated_order_count ?? parent::get_order_count();
	}

	public function get_completed_order_count(): int {
		if ( is_null( $this->calculated_order_count ) ) {
			$this->generate_fake_customer( $this->get_billing_email() );
		}
		return $this->calculated_order_count;
	}

	public function get_is_paying_customer( $context = 'view' ) {
		return is_null( $this->calculated_total_spent ) ? parent::get_is_paying_customer( $context = 'view' ) : ( $this->calculated_total_spent > 0 ); // TODO: Change the autogenerated stub
	}

	/**
	 *
	 *
	 * @return string|null
	 */
	protected function find_billing_email(): ?string {

		// Try use billing_email.
		// It won't be filled out early on but is a required field.
		$billing_email = WC()->checkout()->get_value( 'billing_email' );

		if ( ! is_email( $billing_email ) ) {
			$billing_email = $this->parse_billing_email_from_posted_data();
		}

		if ( is_null( $billing_email ) ) {
			return null;
		}

		return is_email( $billing_email ) ? $billing_email : null;
	}

	/**
	 * Get the billing email from $_POST['post_data'].
	 *
	 * @see WC_Ajax::update_order_review()
	 * @see assets/js/frontend/checkout.js
	 *
	 * @return ?string The billing email address if present.
	 */
	protected function parse_billing_email_from_posted_data(): ?string {

		// WC()->checkout()->get_posted_data()

		if ( empty( $_POST ) ) {
			return null;
		}

		if ( ! isset( $_POST['post_data'] ) ) {
			return null;
		}

		$post_array = array();
		parse_str( wp_unslash( $_POST['post_data'] ), $post_array );

		if ( empty( $post_array['billing_email'] ) ) {
			return null;
		}

		if ( ! is_email( $post_array['billing_email'] ) ) {
			return null;
		}

		return $post_array['billing_email'];
	}

	/**
	 * If there is no WP_User/WC_Customer object, do a database search for the billing_email.
	 *
	 * We create a subclass of WC_Customer object and just not save it (except in cache).
	 *
	 * @param string $email_address
	 */
	protected function generate_fake_customer( $email_address ): void {

		$this->set_billing_email( $email_address );

		$cache_key = 'bh_wc_customer_conditions_' . $email_address;

		// TODO: Should this be expired after an order is placed?
		$cache_expiry_seconds = WEEK_IN_SECONDS;

		/**
		 * @var array{
		 *      order_count: int,
		 *      total_spent: float
		 * }  $customer_data_cache
		 */
		$customer_data_cache = wp_cache_get( $cache_key );

		// Validate/refresh the cached data.
		if ( empty( $customer_data_cache )
			|| ! isset( $customer_data_cache['order_count'] )
			|| ! is_int( $customer_data_cache['order_count'] )
			|| ! isset( $customer_data_cache['total_spent'] )
			|| ! is_numeric( $customer_data_cache['total_spent'] ) ) {

			$customer_data_cache = array();

			/**
			 * Search db for all orders made with the user e-mail as the billing e-mail.
			 *
			 * @var WC_Order[] $customer_orders
			 */
			$customer_orders = wc_get_orders(
				array(
					'status'        => 'wc-completed',
					'billing_email' => $email_address,
					'limit'         => -1, // Assumes most users without accounts have somewhat small numbers of past orders.
				)
			);

			$customer_data_cache['order_count'] = count( $customer_orders );

			/**
			 * @param WC_Order[] $orders
			 *
			 * @return int
			 */
			$calculate_total_spent = function ( $orders ) {
				$total = 0;
				foreach ( $orders as $order ) {
					$total += $order->get_total();
				}

				return $total;
			};

			$customer_data_cache['total_spent'] = $calculate_total_spent( $customer_orders );

			wp_cache_add( $cache_key, $customer_data_cache, '', $cache_expiry_seconds );

		}

		$this->calculated_order_count = $customer_data_cache['order_count'];
		$this->calculated_total_spent = $customer_data_cache['total_spent'];

	}

}
